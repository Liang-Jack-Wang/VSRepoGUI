using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace VSRepoGUI
{
    public class Diagnose
    {
        public string python_bin = "python.exe";
        Dictionary<string, List<string>> dllfiles = new Dictionary<string, List<string>>();

        public Diagnose(string pythonbin)
        {
            this.python_bin = pythonbin;
        }
        public async Task<Dictionary<string, List<string>>> CheckPluginsAsync(string path)
        {
            string code = GetDllCheckCode(path);
            string result = await Task.Run(() => run_python(code));
            Console.WriteLine(result);
            string[][] packages;
            try
            {
                packages = JsonConvert.DeserializeObject<string[][]>(result);
                if (packages == null)
                    return null;
            }
            catch
            {
                return null;
            }
            dllfiles.Add("no_problems", (from file in packages
                                         where file[1].Contains("already loaded")
                                         select file[0]).OrderBy(f => f).ToList());

            dllfiles.Add("not_a_vsplugin", (from file in packages
                                            where file[1].Contains("No entry point found")
                                            select file[0]).OrderBy(f => f).ToList());

            dllfiles.Add("wrong_arch", (from file in packages
                                        where file[1].Contains("returned 193")
                                        select file[0]).OrderBy(f => f).ToList());

            dllfiles.Add("missing_dependency", (from file in packages
                                        where file[1].Contains("returned 126")
                                        select file[0]).OrderBy(f => f).ToList());

            dllfiles.Add("namespace", (from file in packages
                                        where file[1].Contains("already populated")
                                        select file[0]).OrderBy(f => f).ToList());
            
            dllfiles.Add("others", (from file in packages
                                    where !(file[1].Contains("returned 193") || file[1].Contains("No entry point found") || file[1].Contains("already loaded") || file[1].Contains("returned 126") || file[1].Contains("already populated"))
                                    select file[0]).OrderBy(f => f).ToList());
            return dllfiles;
        }

        public async Task<string> GetVsVersion()
        {
            return await Task.Run(() => run_python("import vapoursynth as vs; core = vs.get_core(); print(core.version())"));
        }

        //Do not format this code string
        public string GetDllCheckCode(string path)
        {
            path = path.Replace(@"\\", @"\");
            return string.Format(
@"import sys, os, glob, json
import vapoursynth as vs
core = vs.get_core();
path = path = r'{0}'
plugin_dir = glob.glob(path + '/*.dll')
error = []
for dll in plugin_dir:
    try:
        core.std.LoadPlugin(path = dll)
        core.std.LoadPlugin(path = dll)
    except Exception as e:
        error.append([os.path.basename(dll), str(e)])
        continue
print(json.dumps(error))
            ", path);
        }

        public string run_python(string cmd)
        {
            ProcessStartInfo start = new ProcessStartInfo();
            start.FileName = python_bin;
            start.Arguments = string.Format("-c \"{0}\"", cmd);
            start.UseShellExecute = false;// Do not use OS shell
            start.CreateNoWindow = true; // We don't need new window
            start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            start.RedirectStandardError = false; // Any error in standard output will be redirected back (for example exceptions)
            using (Process process = Process.Start(start))
            {
                using (StreamReader reader = process.StandardOutput)
                {
                    string result = reader.ReadToEnd();
                    return result;
                }
            }
        }
    }
}
